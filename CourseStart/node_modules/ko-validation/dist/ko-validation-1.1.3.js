var ko;
ko = ko || {};
ko.func = ko.func || {};
ko.func.operators = ko.func.operators || {};
ko.validation = ko.validation || {};
ko.validators = ko.validators || {};
ko.validators.results = ko.validators.results || {};
;ko.validators.customValidator = function (validationFn, context) {
  return { validate: validationFn.bind(context) };
};

ko.validators.validatorWithMessage = function (validationFn, message) {
  return ko.validators.customValidator(
    ko.validators.utilities.validateWithMessage(
      validationFn,
      message
    )
  );
};
;ko.validators.dependentFieldNumericValidator = function (otherFieldId, comparator, message) {
  var utils = ko.validators.utilities;

  return ko.validators.validatorWithMessage(
    function (value) {
      var otherFieldValue, valueNumeric, otherFieldValueNumeric;

      otherFieldValue = utils.getValueByElementId(otherFieldId);
      if (!utils.isInteger(otherFieldValue)) {
        return true;
      }

      valueNumeric = parseInt(value, 10);
      otherFieldValueNumeric = parseInt(otherFieldValue, 10);

      return utils.isInteger(value) && comparator(otherFieldValueNumeric)(valueNumeric);
    },
    message
  );
};

ko.validators.lessThanOrEqualToFieldValueValidator = function (otherFieldId, message) {
  return ko.validators.dependentFieldNumericValidator(
    otherFieldId,
    ko.func.operators.lessThanOrEqualTo,
    message
  );
};

ko.validators.greaterThanOrEqualToFieldValueValidator = function (otherFieldId, message) {
  return ko.validators.dependentFieldNumericValidator(
    otherFieldId,
    ko.func.operators.greaterThanOrEqualTo,
    message
  );
};

;ko.validators.emailValidator = function (message) {
  return ko.validators.regexValidator(
    /^[+a-zA-Z0-9_.\-]+@([a-zA-Z0-9\-]+\.)+[a-zA-Z0-9]{2,}$/,
    message
  );
};
;ko.validators.equalToFieldValueValidator = function (otherFieldId, message) {
  var utils = ko.validators.utilities;

  return ko.validators.validatorWithMessage(
    function (value) {
      return value === utils.getValueByElementId(otherFieldId);
    },
    message
  );
};
;ko.validators.integerValidator = function (message) {
  return ko.validators.validatorWithMessage(
    ko.validators.utilities.isInteger,
    message
  );
};

ko.validators.integerValueValidator = function (operation, message) {
  return ko.validators.validatorWithMessage(
    function (value) {
      if (ko.validators.utilities.isDefinedAndNotNull(value)) {
        return ko.validators.utilities.isInteger(value) && operation(parseInt(value, 10));
      }
      return true;
    },
    message
  );
};

ko.validators.rangeValidator = function (min, max, message) {
  return ko.validators.integerValueValidator(
    ko.func.operators.range(min, max),
    message
  );
};

;ko.validators.invalidCharsValidator = function (invalidChars, message) {
  return ko.validators.validatorWithMessage(
    function (value) {
      var valueAsString = value.toString();

      return !ko.utils.arrayFirst(invalidChars, function (character) {
        return (valueAsString.indexOf(character) >= 0);
      });
    },
    message
  );
};

;ko.validators.lengthValidator = function (operation, message) {
  return ko.validators.validatorWithMessage(
    function (value) {
      if (ko.validators.utilities.isDefinedAndNotNull(value)) {
        return operation(value.toString().trim().length);
      }
      return true;
    },
    message
  );
};

ko.validators.maxLengthValidator = function (length, message) {
  return ko.validators.lengthValidator(
    ko.func.operators.lessThanOrEqualTo(length),
    message
  );
};
;ko.validators.onlyIfValidator = function (requirement, actualValidator) {
  var utils = ko.validators.utilities;

  function createValidatorFromConfig(validatorConfig) {
    var name = Object.keys(validatorConfig)[0];

    return ko.validation.utils.createValidator(name, validatorConfig[name]);
  }

  if (!utils.isFunction(actualValidator.validate)) {
    actualValidator = createValidatorFromConfig(actualValidator);
  }

  return {
    validate: function (value) {
      if (!requirement()) {
        return ko.validators.results.valid();
      }
      return actualValidator.validate(value);
    }
  };
};
;ko.validators.regexValidator = function (regex, message) {
  return ko.validators.validatorWithMessage(
    regex.test.bind(regex),
    message
  );
};

;ko.validators.requiredValidator = function (message) {
  var utils = ko.validators.utilities;

  return ko.validators.validatorWithMessage(
    function (value) {
      if (utils.isArray(value)) {
        return value.length > 0;
      }
      if (utils.isNumber(value)) {
        return true;
      }
      return !!value;
    },
    message
  );
};

;ko.validators.results.result = function (isValid, message) {
  return { isValid: isValid, message: message };
};

ko.validators.results.valid = ko.validators.results.result.bind(null, true);
ko.validators.results.invalid = ko.validators.results.result.bind(null, false);
;ko.validators.utilities = (function () {
  var self = {};

  function getSelectSingleValue(element) {
    return element.selectedIndex >= 0 ? element.options[element.selectedIndex].value : null;
  }

  function getSelectMultipleValue(element) {
    var values;

    values = ko.utils.arrayFilter(element.options, function (option) {
      return option.selected;
    });

    values = ko.utils.arrayMap(values, function (option) {
      return option.value;
    });

    return values.length ? values : null;
  }

  self.isArray = function (value) {
    if (!value) {
      return false;
    }
    return Array.isArray(value) || (typeof value === 'object' && typeof value.length === 'number');
  };

  self.isBoolean = function (value) {
    return typeof value === 'boolean';
  };

  self.isString = function (value) {
    return typeof value === 'string';
  };

  self.isNumber = function (num) {
    return !self.isEmptyString(num) && isFinite(num) && (num !== false);
  };

  self.isInteger = function (num) {
    return self.isNumber(num) && num % 1 === 0;
  };

  self.isEmptyString = function (value) {
    return (/^[\s\xa0]*$/).test(value === null ? '' : String(value));
  };

  self.isFunction = function (value) {
    return typeof value === 'function' && Object.prototype.toString.call(value) === '[object Function]';
  };

  self.isDefinedAndNotNull = function (value) {
    return (value !== undefined) && (value !== null);
  };

  self.identity = function (value) {
    return value;
  };

  self.getValue = function (element) {
    var type = element.type;
    if (!type || !type.toLowerCase) { return null; }

    switch (type.toLowerCase()) {
    case 'checkbox':
    case 'radio':
      return element.checked ? element.value : null;
    case 'select-one':
      return getSelectSingleValue(element);
    case 'select-multiple':
      return getSelectMultipleValue(element);
    case 'hidden':
      return element.value || null;
    default:
      return (element.value !== undefined) ? element.value : '';
    }
  };

  self.getValueByElementId = function (elementId) {
    return self.getValue(document.getElementById(elementId));
  };

  self.objectForEach = ko.utils.objectForEach;

  self.makeFunction = function (value) {
    return self.isFunction(value) ? value : self.identity.bind(self, value);
  };

  self.validateWithMessage = function (isValueValidFn, message) {
    var messageFn = self.makeFunction(message);

    return function (value) {
      var isValid = !!isValueValidFn(value);
      return { isValid: isValid, message: isValid ? undefined : messageFn(value) };
    };
  };

  return self;
}());
;ko.func.operators = (function () {
  var self = {};

  self.strictEquals = function (other) {
    return function (value) {
      return value === other;
    };
  };

  self.greaterThan = function (minimum) {
    return function (value) {
      return value > minimum;
    };
  };

  self.greaterThanOrEqualTo = function (minimum) {
    return function (value) {
      return value >= minimum;
    };
  };

  self.lessThan = function (minimum) {
    return function (value) {
      return value < minimum;
    };
  };

  self.lessThanOrEqualTo = function (maximum) {
    return function (value) {
      return value <= maximum;
    };
  };

  self.range = function (minimum, maximum) {
    return function (value) {
      return self.greaterThanOrEqualTo(minimum)(value)
          && self.lessThanOrEqualTo(maximum)(value);
    };
  };

  return self;
}());
;ko.validation.validationStates = {
  PRISTINE: 'pristine',
  INVALID: 'invalid',
  VALID: 'valid',
  FIXED: 'fixed'
};

ko.validation.registeredValidators = {};

ko.validation.utils = (function () {
  var self = {};

  self.validatesOtherObservable = function (observable) {
    return !!observable.__validates__;
  };

  self.hasValidators = function (observable) {
    return observable.__validators__ && observable.validationState;
  };

  self.createValidator = function (name, params) {
    var validatorFactory = ko.validation.registeredValidators[name];

    if (typeof validatorFactory !== 'function') {
      throw new Error([
        'Cannot create validator with name "',
        name,
        '". Validator class is ',
        validatorFactory || 'not registered.'
      ].join(''));
    }

    return validatorFactory.apply(this, params);
  };

  self.runValidations = function (observable) {
    if (self.hasValidators(observable)) {
      var i, validator, validationResult, currentState;

      for (i = 0; i < observable.__validators__.length; i++) {
        validator = observable.__validators__[i];
        validationResult = validator.validate(observable());
        if (!validationResult.isValid) {
          observable.validationMessage(validationResult.message || '');
          observable.validationState(ko.validation.validationStates.INVALID);
          return;
        }
      }

      currentState = observable.validationState();
      if (currentState !== ko.validation.validationStates.VALID) {
        observable.validationMessage('');
        observable.validationState(
          currentState === ko.validation.validationStates.INVALID
            ? ko.validation.validationStates.FIXED
            : ko.validation.validationStates.VALID
        );
      }
    }
  };

  self.addValidateToViewModel = function (viewModel) {
    if (!viewModel) {
      return;
    }
    viewModel.validate = viewModel.validate || function () {
      var propertyName, observable, valid;

      valid = true;
      for (propertyName in viewModel) {
        if (viewModel.hasOwnProperty(propertyName)) {
          observable = viewModel[propertyName];
          if (self.hasValidators(observable)) {
            self.runValidations(observable);
            valid = observable.isValid() && valid;
          }
        }
      }

      return valid;
    };
  };

  return self;
}());

ko.validation.registerValidator = function (name, validatorFactory) {
  ko.validation.registeredValidators[name] = validatorFactory;
  ko.extenders[name] = function (observable, param) {
    var isFirstValidatorForObservable, validator;

    isFirstValidatorForObservable = !observable.__validators__;

    if (isFirstValidatorForObservable) {
      observable.__validators__ = [];
      observable.validationState = ko.observable(
        ko.validation.validationStates.PRISTINE
      ).extend({
        'notify': 'always'
      });
      observable.validationMessage = ko.observable('');
      observable.validate = function () {
        ko.validation.utils.runValidations(observable);
      };
      observable.isValid = ko.computed(function () {
        return observable.validationState() !== ko.validation.validationStates.INVALID;
      });
      observable.subscribe(function () {
        ko.validation.utils.runValidations(observable);
      });
    }

    validator = ko.validation.utils.createValidator(name, param);
    observable.__validators__.push(validator);

    return observable;
  };
};

(function () {
  function insertOrGetMessageElementAt(element) {
    var validationElement = element.querySelector('.validation-message');
    if (!validationElement) {
      validationElement = document.createElement('SPAN');
      validationElement.className = 'validation-message';
      validationElement.style.display = 'none';
      element.appendChild(validationElement);
    }
    return validationElement;
  }

  function updateValidationMessage(element, observable) {
    ko.bindingHandlers.visible.update(element, function () {
      return observable.validationState() !== ko.validation.validationStates.PRISTINE;
    });
    ko.bindingHandlers.css.update(element, function () {
      return {
        'validation-error': observable.validationState() === ko.validation.validationStates.INVALID,
        'validation-fixed': observable.validationState() === ko.validation.validationStates.FIXED
      };
    });
    ko.bindingHandlers.text.update(element, observable.validationMessage);
    if (element.parentNode) {
      ko.bindingHandlers.css.update(element.parentNode, function () {
        return {
          'error': observable.validationState() === ko.validation.validationStates.INVALID
        };
      });
    }
  }

  function initValidationFor(inputElement, observable) {
    var messageSubscription = observable.validationState.subscribe(function () {
      if (observable.__hasCustomValidationElement__) {
        messageSubscription.dispose();
        return;
      }
      var validationElement = insertOrGetMessageElementAt(inputElement.parentNode);
      updateValidationMessage(validationElement, observable);
    });

    ko.utils.domNodeDisposal.addDisposeCallback(inputElement, function () {
      messageSubscription.dispose();
    });
  }

  ko.extenders.validatesAfter = function (observable, dependentObservables) {
    ko.utils.arrayForEach(dependentObservables, function (dependentObservable) {
      if (!ko.isObservable(dependentObservable)) {
        throw new Error('Invalid observable specified for "validatesAfter"');
      }
      dependentObservable.__validates__ = dependentObservable.__validates__ || [];
      dependentObservable.__validates__.push(observable);
    });
    return observable;
  };

  ko.extenders.validates = function (observable, dependentObservables) {
    ko.utils.arrayForEach(dependentObservables, function (dependentObservable) {
      observable.subscribe(function () {
        ko.validation.utils.runValidations(dependentObservable);
      });
    });
    return observable;
  };

  ko.bindingHandlers.validationMessage = {
    init: function (element, valueAccessor) {
      var observable, subscription;

      observable = valueAccessor();
      if (!ko.validation.utils.hasValidators(observable)) {
        throw new Error("'validationMessage' should be used with an observable that has validation");
      }

      observable.__hasCustomValidationElement__ = true;
      ko.bindingHandlers.css.update(element, function () {
        return { 'validation-message': true };
      });
      subscription = observable.validationState.subscribe(function () {
        updateValidationMessage(element, observable);
      });
      ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
        subscription.dispose();
      });
    }
  };

  function makeHandlerValidatable(handler) {
    var originalInit = ko.bindingHandlers[handler].init;

    ko.bindingHandlers[handler].init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
      var observable, originalReturn;

      observable = valueAccessor();
      originalReturn = originalInit(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);

      if (ko.isObservable(observable)) {
        if (ko.validation.utils.hasValidators(observable)) {
          initValidationFor(element, observable);
        }

        if (ko.validation.utils.validatesOtherObservable(observable)) {
          ko.utils.arrayForEach(observable.__validates__, function (dependentObservable) {
            initValidationFor(element, dependentObservable);
          });
        }

        ko.validation.utils.addValidateToViewModel(viewModel);
      }

      return originalReturn;
    };
  }

  makeHandlerValidatable('value');
  makeHandlerValidatable('checked');
}());
;(function () {
  ko.validation.registerValidator('required', ko.validators.requiredValidator);
  ko.validation.registerValidator('maxLength', ko.validators.maxLengthValidator);
  ko.validation.registerValidator('custom', ko.validators.customValidator);

  ko.validation.registerValidator('integer', ko.validators.integerValidator);
  ko.validation.registerValidator('range', ko.validators.rangeValidator);

  ko.validation.registerValidator('regex', ko.validators.regexValidator);
  ko.validation.registerValidator('email', ko.validators.emailValidator);
  ko.validation.registerValidator('invalidChars', ko.validators.invalidCharsValidator);

  ko.validation.registerValidator('onlyIf', ko.validators.onlyIfValidator);

  ko.validation.registerValidator('equalToFieldValue', ko.validators.equalToFieldValueValidator);
  ko.validation.registerValidator('greaterThanOrEqualToFieldValue', ko.validators.greaterThanOrEqualToFieldValueValidator);
  ko.validation.registerValidator('lessThanOrEqualToFieldValue', ko.validators.lessThanOrEqualToFieldValueValidator);
}());

